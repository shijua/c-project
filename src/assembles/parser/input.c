#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include "input.h"
#include "parser.h"
#include "../Util.h"
// if previous is , or : or is ended
#define IS_REDUNDANT(str, i) ((str[i-1] == ',') || str[i-1] == ':' || str[i+1] == '\0' || str[i+1] == '\n' || isspace(str[i+1]))
char *readfile(char *filename)
{
    FILE *input = fopen(filename, "r"); // Open the file in read
    assert(input != NULL);
    // Get the file size
    fseek(input, 0, SEEK_END); // Go to the end of the file
    int file_size = ftell(input);
    fseek(input, 0, SEEK_SET); // Go back to the beginning of the file
    // Read the file into a buffer
    char *buffer = malloc(file_size + 1);
    fread(buffer, file_size, 1, input);
    // close file after store into buffer
    fclose(input);
    return buffer;
}


// remove unused white space
// TODO comment on whitespace
void remove_whitespace(char* str) {
    char* new_str = malloc(strlen(str) + 1); // allocate memory for the new string
    if (new_str == NULL) {
        printf("Failed to allocate memory\n");
        return;
    }
    int j = 0;
    bool flag = true;
    // check whether it touches the first word
    for (int i = 0; str[i] != '\0'; i++) {
        // check if the space need to be removed (flag checking for start, is redundant checking for previous and end)
        // also not accepting str[i] == '\n'
        if (!((isspace(str[i]) && (flag || IS_REDUNDANT(str, i))) || str[i] == '\n')) {
            // set to false after meet first char 
            flag = false;
            new_str[j] = str[i]; // copy the character to the new string
            j++;
        }
    }
    new_str[j] = '\0'; // add null terminator to the end of the new string
    strcpy(str, new_str);
    free(new_str);
}

void build_symbol_table(char *buffer, struct symbol_table *table, int file_size)
{
    // set the address of the first line for storge
    int address = 0;
    // the start of the next line
    int line_start = 0;
    for (int i = 0; i < file_size; i++)
    {
        if (buffer[i] == '\n')
        {
            // jump empty line
            if(line_start == i) {
                line_start++;
                continue;
            }
            // copy the line into line (don't include '\n')
            char *line = substring(buffer, line_start, i);
            // if the last character is ':' then it is a label
            remove_whitespace(line);
            if (line[strlen(line) - 1] == ':')
            {
                // remove the ':' from the label
                line[strlen(line) - 1] = '\0';
                symbol_table_push(table, line, address);
            } else {
                address += 4;
            }
            // set for next line
            line_start = i + 1;
            free(line);
        }
    }
}

void generate_binary(char *buffer, char *filename, struct symbol_table *table, int file_size)
{
    // read the file for writing
    FILE *output = fopen(filename, "wb");
    assert(output != NULL);
    // set the address of the first line (may be used in branch etc.)
    int address = 0;
    // the start of the next line
    int line_start = 0;
    // store the 32-bit instruction generated by parse
    unsigned int *instruction = malloc(sizeof(int));
    for (int i = 0; i < file_size; i++)
    {   
        // if the line is end or the file is end
        if (buffer[i] == '\n' || i == file_size - 1)
        {
            *instruction = 0;
            // if file is end need to + 2
            if( i == file_size - 1) i += 2;
            // copy the line into line (don't include '\n')
            char *line = substring(buffer, line_start, i);
            // if the last character is ':' then it is a label or skip empty line
            remove_whitespace(line);
            if (line[strlen(line) - 1] == ':' || strlen(line) == 0) {
                line_start = i+1; 
                continue;
            }
            parse(line, address, instruction, table);
            // set for next line
            line_start = i + 1;
            address += 4;
            // write instrucion into file
            fwrite(instruction, 4, 1, output);
        }
    }
    free(instruction);
    fclose(output);
}
