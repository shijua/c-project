#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#include "input.h"
#include "parser.h"
#include "../Util.h"
char *readfile(char *filename)
{
    FILE *input = fopen(filename, "r"); // Open the file in read
    assert(input != NULL);
    // Get the file size
    fseek(input, 0, SEEK_END); // Go to the end of the file
    int file_size = ftell(input);
    fseek(input, 0, SEEK_SET); // Go back to the beginning of the file
    // Read the file into a buffer
    char *buffer = malloc(file_size + 1);
    fread(buffer, file_size, 1, input);
    // close file after store into buffer
    fclose(input);
    return buffer;
}

void build_symbol_table(char *buffer, struct symbol_table *table, int file_size)
{
    // set the address of the first line for storge
    int address = 0;
    // the start of the next line
    int line_start = 0;
    for (int i = 0; i < file_size; i++)
    {
        if (buffer[i] == '\n')
        {
            // copy the line into line (don't include '\n')
            char *line = substring(buffer, line_start, i);
            // if the last character is ':' then it is a label
            if (line[strlen(line) - 1] == ':')
            {
                // remove the ':' from the label
                line[strlen(line) - 1] = '\0';
                symbol_table_push(table, line, address);
            }
            // set for next line
            line_start = i + 1;
            address += 1;
            free(line);
        }
    }
}

// remove unused white space
// TODO comment on whitespace
void remove_whitespace(char* str) {
    char* new_str = malloc(strlen(str) + 1); // allocate memory for the new string
    if (new_str == NULL) {
        printf("Failed to allocate memory\n");
        return;
    }
    int j = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (!(isspace(str[i]) && (i == 0 || str[i-1] == ','|| str[i-1] == '#'))) { // check if the character is not a white space character
            new_str[j] = str[i]; // copy the character to the new string
            j++;
        }
    }
    new_str[j] = '\0'; // add null terminator to the end of the new string
    strcpy(str, new_str);
    free(new_str);
}


void generate_binary(char *buffer, char *filename, struct symbol_table *table, int file_size)
{
    // read the file for writing
    FILE *output = fopen(filename, "wb");
    assert(output != NULL);
    // set the address of the first line (may be used in branch etc.)
    int address = 0;
    // the start of the next line
    int line_start = 0;
    // store the 32-bit instruction generated by parse
    unsigned int *instruction = malloc(sizeof(int));
    for (int i = 0; i < file_size; i++)
    {
        // if the line is end or the file is end
        if (buffer[i] == '\n' || i == file_size - 1)
        {
            *instruction = 0;
            if(line_start == i) continue;
            // copy the line into line (don't include '\n')
            char *line = substring(buffer, line_start, i);
            // if the last character is ':' then it is a label or skip empty line
            if (line[strlen(line) - 1] == ':' || line_start == i) {
                line_start = i+1; 
                continue;
            }
            remove_whitespace(line);
            parse(line, address, instruction, table);
            // set for next line
            line_start = i + 1;
            address += 1;
            // write instrucion into file
            fwrite(instruction, 4, 1, output);
            free(line);
        }
    }
    free(instruction);
    fclose(output);
}
